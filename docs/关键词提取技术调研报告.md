# å…³é”®è¯æå–æŠ€æœ¯è°ƒç ”æŠ¥å‘Š

> **è°ƒç ”ç›®æ ‡**ï¼šä¸º RAG çŸ¥è¯†åº“ç³»ç»Ÿé€‰æ‹©æœ€ä½³çš„å…³é”®è¯æå–æ–¹æ¡ˆï¼Œç”¨äºæå‡æ··åˆæ£€ç´¢ï¼ˆå‘é‡ + BM25ï¼‰çš„å‡†ç¡®ç‡
>
> **æŠ€æœ¯è¦æ±‚**ï¼šæœ¬åœ°åŒ–è¿è¡Œã€ä¸­æ–‡æ”¯æŒã€Node.js å®ç°ã€ä¸ Ollama é›†æˆ
>
> **æŠ¥å‘Šæ—¥æœŸ**ï¼š2025-01-23
>
> **è°ƒç ”äººå‘˜**ï¼šClaude Code

---

## ç›®å½•

- [æ‰§è¡Œæ‘˜è¦](#æ‰§è¡Œæ‘˜è¦)
- [1. æŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”](#1-æŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”)
- [2. æ¨èæ–¹æ¡ˆè¯¦è§£](#2-æ¨èæ–¹æ¡ˆè¯¦è§£)
- [3. Node.js å®ç°ä»£ç ç¤ºä¾‹](#3-nodejs-å®ç°ä»£ç ç¤ºä¾‹)
- [4. æ€§èƒ½è¯„ä¼°](#4-æ€§èƒ½è¯„ä¼°)
- [5. æ¨èå†³ç­–](#5-æ¨èå†³ç­–)
- [6. å‚è€ƒèµ„æº](#6-å‚è€ƒèµ„æº)

---

## æ‰§è¡Œæ‘˜è¦

**æ ¸å¿ƒå‘ç°**ï¼š

1. **æœ€ä½³å¹³è¡¡æ–¹æ¡ˆ**ï¼š`@node-rs/jieba` + TF-IDF/TextRankï¼ˆæœ¬åœ°åŒ–ã€å¿«é€Ÿã€ä¸­æ–‡ä¼˜åŒ–ï¼‰
2. **æœ€é«˜å‡†ç¡®ç‡æ–¹æ¡ˆ**ï¼šOllama + Qwen æç¤ºè¯å·¥ç¨‹ï¼ˆåˆ©ç”¨ç°æœ‰åŸºç¡€è®¾æ–½ï¼‰
3. **æ¨èç»„åˆç­–ç•¥**ï¼šçŸ­æ–‡æœ¬ç”¨ jiebaï¼ˆé€Ÿåº¦ä¼˜å…ˆï¼‰ï¼Œé•¿æ–‡æœ¬ç”¨ LLMï¼ˆè´¨é‡ä¼˜å…ˆï¼‰
4. **å…³é”®è¯æ•°é‡**ï¼šRAG ç³»ç»Ÿæ¨è **3-5 ä¸ªå…³é”®è¯**
5. **æ··åˆæ£€ç´¢ä¼˜åŒ–**ï¼šå…³é”®è¯åº”é…åˆ BM25ï¼Œalpha å‚æ•°å»ºè®® 0.6-0.7

---

## 1. æŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”

### 1.1 æ–¹æ¡ˆçŸ©é˜µ

| æ–¹æ¡ˆ | æœ¬åœ°åŒ– | ä¸­æ–‡æ”¯æŒ | å®ç°éš¾åº¦ | å¤„ç†é€Ÿåº¦ | å‡†ç¡®ç‡ | èµ„æºæ¶ˆè€— | æ¨èæŒ‡æ•° |
|------|--------|----------|----------|----------|--------|----------|----------|
| **TF-IDF** | âœ… å®Œå…¨æœ¬åœ° | âš ï¸ éœ€ä¸­æ–‡åˆ†è¯ | â­ ç®€å• | âš¡ æå¿« (2s/2000doc) | â­â­ ä¸­ç­‰ | ğŸ’š ä½ | â­â­â­ |
| **RAKE** | âœ… å®Œå…¨æœ¬åœ° | âŒ è‹±æ–‡ä¼˜åŒ– | â­ ç®€å• | âš¡ æå¿« (160ms/500doc) | â­â­â­ è‰¯å¥½ | ğŸ’š ä½ | â­â­ |
| **TextRank** | âœ… å®Œå…¨æœ¬åœ° | âš ï¸ éœ€ä¸­æ–‡åˆ†è¯ | â­â­ ä¸­ç­‰ | ğŸ¢ æ…¢ (1s/500doc) | â­â­â­â­ ä¼˜ç§€ | ğŸ’š ä½ | â­â­â­â­ |
| **YAKE** | âœ… å®Œå…¨æœ¬åœ° | âš ï¸ å¤šè¯­è¨€ | â­â­ ä¸­ç­‰ | âš¡ å¿« | â­â­â­â­ ä¼˜ç§€ | ğŸ’š ä½ | â­â­â­â­ |
| **KeyBERT** | âš ï¸ éœ€é¢„è®­ç»ƒæ¨¡å‹ | âœ… å¤šè¯­è¨€ | â­â­â­ å¤æ‚ | ğŸ¢ æ…¢ | â­â­â­â­â­ å“è¶Š | ğŸ’› ä¸­-é«˜ | â­â­â­ |
| **jieba (TF-IDF/TextRank)** | âœ… å®Œå…¨æœ¬åœ° | âœ… ä¸­æ–‡ä¸“ç”¨ | â­ ç®€å• | âš¡ å¿« (1.5MB/s) | â­â­â­â­ ä¼˜ç§€ | ğŸ’š ä½ | â­â­â­â­â­ |
| **Ollama + Qwen** | âœ… æœ¬åœ°éƒ¨ç½² | âœ… ä¸­æ–‡ä¼˜åŒ– | â­â­ ä¸­ç­‰ | ğŸ¢ æ…¢ | â­â­â­â­â­ å“è¶Š | ğŸ’› ä¸­-é«˜ | â­â­â­â­â­ |

### 1.2 ç®—æ³•åŸç†å¯¹æ¯”

#### TF-IDFï¼ˆTerm Frequency-Inverse Document Frequencyï¼‰
**åŸç†**ï¼šè®¡ç®—è¯é¢‘ä¸é€†æ–‡æ¡£é¢‘ç‡çš„ä¹˜ç§¯
- **ä¼˜ç‚¹**ï¼šç®€å•ã€å¿«é€Ÿã€æ˜“ç†è§£
- **ç¼ºç‚¹**ï¼šæ— æ³•è¯†åˆ«è¯­ä¹‰å…³è”ã€éœ€è¦æ–‡æ¡£é›†åˆ
- **é€‚ç”¨åœºæ™¯**ï¼šå¤§é‡æ–‡æ¡£é›†åˆã€å¿«é€Ÿç´¢å¼•

#### RAKEï¼ˆRapid Automatic Keyword Extractionï¼‰
**åŸç†**ï¼šæ„å»ºè¯-è¯å…±ç°å›¾ï¼ŒåŸºäºè¯é¢‘å’Œè¯åº¦æ‰“åˆ†
- **ä¼˜ç‚¹**ï¼šæ— éœ€è®­ç»ƒã€æå¿«ã€é€‚åˆé•¿å…³é”®è¯
- **ç¼ºç‚¹**ï¼šä¸»è¦ä¸ºè‹±æ–‡ä¼˜åŒ–ã€ä¸­æ–‡éœ€è¦é¢å¤–å¤„ç†
- **é€‚ç”¨åœºæ™¯**ï¼šè‹±æ–‡æ–‡æ¡£ã€æŠ€æœ¯æ–‡æ¡£

#### TextRank
**åŸç†**ï¼šåŸºäºå›¾çš„æ’åç®—æ³•ï¼ˆç±»ä¼¼ PageRankï¼‰
- **ä¼˜ç‚¹**ï¼šè€ƒè™‘è¯è¯­å…³ç³»ã€æ— éœ€è®­ç»ƒ
- **ç¼ºç‚¹**ï¼šè®¡ç®—è¾ƒæ…¢ã€ä¾èµ–åˆ†è¯è´¨é‡
- **é€‚ç”¨åœºæ™¯**ï¼šä¸­é•¿æ–‡æœ¬ã€é‡è§†è¯­ä¹‰å…³è”

#### YAKEï¼ˆYet Another Keyword Extractorï¼‰
**åŸç†**ï¼šåŸºäºç»Ÿè®¡ç‰¹å¾ï¼ˆä½ç½®ã€é¢‘ç‡ã€ä¸Šä¸‹æ–‡ç­‰ï¼‰
- **ä¼˜ç‚¹**ï¼šæ— éœ€è®­ç»ƒã€å¤šè¯­è¨€ã€è½»é‡çº§
- **ç¼ºç‚¹**ï¼šNode.js å®ç°è¾ƒå°‘ã€æ–‡æ¡£ä¸å…¨
- **é€‚ç”¨åœºæ™¯**ï¼šå¤šè¯­è¨€ç¯å¢ƒã€å•æ–‡æ¡£å¤„ç†

#### KeyBERT
**åŸç†**ï¼šä½¿ç”¨ BERT åµŒå…¥è®¡ç®—æ–‡æ¡£ä¸å€™é€‰è¯çš„ä½™å¼¦ç›¸ä¼¼åº¦
- **ä¼˜ç‚¹**ï¼šå‡†ç¡®ç‡æœ€é«˜ã€è¯­ä¹‰ç†è§£å¼º
- **ç¼ºç‚¹**ï¼šéœ€è¦ Python ç¯å¢ƒã€èµ„æºæ¶ˆè€—é«˜ã€é€Ÿåº¦æ…¢
- **é€‚ç”¨åœºæ™¯**ï¼šè´¨é‡ä¼˜å…ˆã€Python é¡¹ç›®

#### jieba + TF-IDF/TextRank
**åŸç†**ï¼šä¸­æ–‡åˆ†è¯ + å…³é”®è¯æå–ç®—æ³•
- **ä¼˜ç‚¹**ï¼šä¸“ä¸ºä¸­æ–‡ä¼˜åŒ–ã€é€Ÿåº¦å¿«ã€Node.js åŸç”Ÿæ”¯æŒ
- **ç¼ºç‚¹**ï¼šä»…é™ä¸­æ–‡ã€è¯å…¸ä¾èµ–
- **é€‚ç”¨åœºæ™¯**ï¼šä¸­æ–‡ä¸ºä¸»çš„ RAG ç³»ç»Ÿ

#### LLM æç¤ºè¯å·¥ç¨‹ï¼ˆOllama + Qwenï¼‰
**åŸç†**ï¼šä½¿ç”¨å¤§æ¨¡å‹é€šè¿‡æç¤ºè¯ç›´æ¥æå–å…³é”®è¯
- **ä¼˜ç‚¹**ï¼šå‡†ç¡®ç‡é«˜ã€å¯å®šåˆ¶ã€ç†è§£è¯­ä¹‰
- **ç¼ºç‚¹**ï¼šé€Ÿåº¦æ…¢ã€èµ„æºæ¶ˆè€—é«˜
- **é€‚ç”¨åœºæ™¯**ï¼šé«˜è´¨é‡è¦æ±‚ã€å¤æ‚æ–‡æœ¬

---

## 2. æ¨èæ–¹æ¡ˆè¯¦è§£

### æ–¹æ¡ˆ Aï¼šjieba + TF-IDFï¼ˆå¿«é€Ÿæ–¹æ¡ˆï¼‰â­â­â­â­â­

#### æŠ€æœ¯åŸç†
ä½¿ç”¨ `@node-rs/jieba` è¿›è¡Œä¸­æ–‡åˆ†è¯ï¼Œç»“åˆ TF-IDF ç®—æ³•æå–å…³é”®è¯ã€‚è¿™æ˜¯ Rust å®ç°çš„ Node.js ç»‘å®šï¼Œæ¯”çº¯ JavaScript å®ç°å¿« 33%ã€‚

#### ä¼˜ç‚¹
- âœ… **å®Œå…¨æœ¬åœ°åŒ–**ï¼šæ— éœ€å¤–éƒ¨ API
- âœ… **ä¸­æ–‡ä¸“ç”¨ä¼˜åŒ–**ï¼šåŸºäºå¤§è§„æ¨¡ä¸­æ–‡è¯å…¸
- âœ… **æ€§èƒ½ä¼˜å¼‚**ï¼š1.5 MB/s å¤„ç†é€Ÿåº¦
- âœ… **Node.js åŸç”Ÿ**ï¼šæ— éœ€ Python ç¯å¢ƒ
- âœ… **èµ„æºæ¶ˆè€—ä½**ï¼šå†…å­˜å ç”¨å°ï¼ˆè¯å…¸çº¦ 35MBï¼‰
- âœ… **æ˜“äºé›†æˆ**ï¼šä¸ better-sqlite3 é…åˆè‰¯å¥½

#### ç¼ºç‚¹
- âš ï¸ **ä»…æ”¯æŒä¸­æ–‡**ï¼šè‹±æ–‡éœ€å…¶ä»–æ–¹æ¡ˆ
- âš ï¸ **è¯å…¸ä¾èµ–**ï¼šæ–°è¯è¯†åˆ«èƒ½åŠ›æœ‰é™
- âš ï¸ **ç»Ÿè®¡æ–¹æ³•**ï¼šæ— æ·±åº¦è¯­ä¹‰ç†è§£

#### å®ç°æ­¥éª¤

```javascript
// 1. å®‰è£…ä¾èµ–
// npm install @node-rs/jieba

// 2. åˆå§‹åŒ– jieba
import { Jieba, TfIdf } from '@node-rs/jieba';
import { dict, idf } from '@node-rs/jieba/dict';

const jieba = Jieba.withDict(dict);
const tfIdf = TfIdf.withDict(idf);

// 3. æå–å…³é”®è¯
function extractKeywords(text, topK = 5) {
  return tfIdf.extractKeywords(jieba, text, topK);
}

// 4. æ‰¹é‡å¤„ç†
function batchExtract(documents, topK = 5) {
  return documents.map(doc => ({
    text: doc,
    keywords: extractKeywords(doc, topK)
  }));
}
```

#### é€‚ç”¨åœºæ™¯
- ç”¨æˆ·é—®å·ç­”æ¡ˆï¼ˆä¸­æ–‡ä¸ºä¸»ï¼‰
- é¡¹ç›®æ€»ç»“æ–‡æ¡£
- å¿«é€Ÿæ‰¹é‡å¤„ç†
- å®æ—¶å…³é”®è¯æå–

#### æ€§èƒ½é¢„ä¼°
- **100 æ¡æ–‡æœ¬**ï¼š< 1 ç§’
- **1000 æ¡æ–‡æœ¬**ï¼š< 10 ç§’
- **å†…å­˜æ¶ˆè€—**ï¼š< 100MB

---

### æ–¹æ¡ˆ Bï¼šjieba + TextRankï¼ˆè´¨é‡æå‡æ–¹æ¡ˆï¼‰â­â­â­â­

#### æŠ€æœ¯åŸç†
TextRank æ˜¯åŸºäºå›¾çš„æ’åç®—æ³•ï¼Œé€šè¿‡æ„å»ºè¯è¯­å…±ç°ç½‘ç»œæ¥è¯†åˆ«å…³é”®è¯ã€‚ç›¸æ¯” TF-IDFï¼Œæ›´èƒ½æ•æ‰è¯è¯­ä¹‹é—´çš„å…³è”ã€‚

#### ä¼˜ç‚¹
- âœ… **æ›´é«˜å‡†ç¡®ç‡**ï¼šè€ƒè™‘è¯è¯­å…³è”
- âœ… **æ— éœ€æ–‡æ¡£é›†åˆ**ï¼šå•æ–‡æ¡£å³å¯æå–
- âœ… **è¯­ä¹‰æ„ŸçŸ¥**ï¼šè¯†åˆ«é‡è¦æ¦‚å¿µ
- âœ… **ä¸­æ–‡ä¼˜åŒ–**ï¼šé…åˆ jieba åˆ†è¯

#### ç¼ºç‚¹
- âš ï¸ **é€Ÿåº¦è¾ƒæ…¢**ï¼šæ¯” TF-IDF æ…¢ 6 å€
- âš ï¸ **å‚æ•°è°ƒä¼˜**ï¼šéœ€è¦è°ƒæ•´çª—å£å¤§å°ç­‰å‚æ•°

#### å®ç°æ­¥éª¤

```javascript
// æ³¨æ„ï¼š@node-rs/jieba ç›®å‰ä¸»è¦æš´éœ² TF-IDF API
// TextRank éœ€è¦ä½¿ç”¨åº•å±‚ jieba-rs æˆ– nodejieba

// æ–¹æ¡ˆ 1ï¼šä½¿ç”¨ nodejiebaï¼ˆä¼ ç»Ÿå®ç°ï¼‰
import nodejieba from 'nodejieba';

function extractKeywordsTextRank(text, topK = 5) {
  return nodejieba.textRankExtract(text, topK);
}

// æ–¹æ¡ˆ 2ï¼šæ‰‹åŠ¨å®ç° TextRankï¼ˆåŸºäº jieba åˆ†è¯ï¼‰
class TextRankExtractor {
  constructor(windowSize = 5, dampingFactor = 0.85) {
    this.windowSize = windowSize;
    this.dampingFactor = dampingFactor;
  }

  extract(jieba, text, topK = 5) {
    // 1. åˆ†è¯
    const words = jieba.cut(text);

    // 2. æ„å»ºå…±ç°å›¾
    const graph = this.buildGraph(words);

    // 3. è¿­ä»£è®¡ç®—æƒé‡
    const scores = this.calculateScores(graph);

    // 4. æ’åºè¿”å›
    return this.getTopK(scores, topK);
  }

  buildGraph(words) {
    const graph = new Map();
    // æ»‘åŠ¨çª—å£æ„å»ºå…±ç°å…³ç³»
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      if (!graph.has(word)) graph.set(word, new Map());

      for (let j = i + 1; j < Math.min(i + this.windowSize, words.length); j++) {
        const coWord = words[j];
        const edges = graph.get(word);
        edges.set(coWord, (edges.get(coWord) || 0) + 1);
      }
    }
    return graph;
  }

  calculateScores(graph) {
    // TextRank è¿­ä»£ç®—æ³•å®ç°
    // ...ï¼ˆå®Œæ•´å®ç°è§ä»£ç ç¤ºä¾‹ç« èŠ‚ï¼‰
  }
}
```

#### é€‚ç”¨åœºæ™¯
- é•¿æ–‡æœ¬ï¼ˆæŠ€æœ¯æ–‡æ¡£ã€é¡¹ç›®æ€»ç»“ï¼‰
- è´¨é‡ä¼˜å…ˆåœºæ™¯
- éœ€è¦è¯†åˆ«æ ¸å¿ƒæ¦‚å¿µ

#### æ€§èƒ½é¢„ä¼°
- **100 æ¡æ–‡æœ¬**ï¼š5-10 ç§’
- **1000 æ¡æ–‡æœ¬**ï¼š1-2 åˆ†é’Ÿ
- **å†…å­˜æ¶ˆè€—**ï¼š< 150MB

---

### æ–¹æ¡ˆ Cï¼šOllama + Qwen æç¤ºè¯å·¥ç¨‹ï¼ˆé«˜è´¨é‡æ–¹æ¡ˆï¼‰â­â­â­â­â­

#### æŠ€æœ¯åŸç†
åˆ©ç”¨é¡¹ç›®å·²éƒ¨ç½²çš„ Ollama + Qwen æ¨¡å‹ï¼Œé€šè¿‡ç²¾å¿ƒè®¾è®¡çš„æç¤ºè¯è®© LLM ç›´æ¥æå–å…³é”®è¯ã€‚æ”¯æŒå¤æ‚è¯­ä¹‰ç†è§£å’Œä¸Šä¸‹æ–‡åˆ†æã€‚

#### ä¼˜ç‚¹
- âœ… **æœ€é«˜å‡†ç¡®ç‡**ï¼šæ·±åº¦è¯­ä¹‰ç†è§£
- âœ… **çµæ´»å¯å®šåˆ¶**ï¼šé€šè¿‡æç¤ºè¯è°ƒæ•´ç­–ç•¥
- âœ… **åˆ©ç”¨ç°æœ‰åŸºç¡€è®¾æ–½**ï¼šæ— éœ€é¢å¤–éƒ¨ç½²
- âœ… **ä¸­æ–‡ä¼˜åŒ–**ï¼šQwen å¯¹ä¸­æ–‡æ”¯æŒä¼˜å¼‚
- âœ… **ç»“æ„åŒ–è¾“å‡º**ï¼šæ”¯æŒ JSON Schema

#### ç¼ºç‚¹
- âš ï¸ **é€Ÿåº¦æ…¢**ï¼šæ¯æ¡ 1-3 ç§’
- âš ï¸ **èµ„æºæ¶ˆè€—é«˜**ï¼šGPU/CPU å ç”¨
- âš ï¸ **ä¸é€‚åˆæ‰¹é‡**ï¼šå®æ—¶å¤„ç†å—é™

#### å®ç°æ­¥éª¤

```javascript
import axios from 'axios';

class OllamaKeywordExtractor {
  constructor(baseURL = 'http://localhost:11434', model = 'qwen2.5:latest') {
    this.baseURL = baseURL;
    this.model = model;
  }

  async extract(text, topK = 5) {
    const prompt = this.buildPrompt(text, topK);

    const response = await axios.post(`${this.baseURL}/api/generate`, {
      model: this.model,
      prompt: prompt,
      format: 'json', // ç»“æ„åŒ–è¾“å‡º
      stream: false,
      options: {
        temperature: 0.3, // é™ä½éšæœºæ€§
        top_p: 0.8
      }
    });

    return JSON.parse(response.data.response);
  }

  buildPrompt(text, topK) {
    return `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å…³é”®è¯æå–ä¸“å®¶ã€‚è¯·ä»ä»¥ä¸‹æ–‡æœ¬ä¸­æå– ${topK} ä¸ªæœ€é‡è¦çš„å…³é”®è¯æˆ–çŸ­è¯­ã€‚

è¦æ±‚ï¼š
1. å…³é”®è¯åº”æ˜¯åè¯ã€æ ¸å¿ƒæ¦‚å¿µæˆ–ä¸“ä¸šæœ¯è¯­
2. ä¼˜å…ˆé€‰æ‹©èƒ½ä»£è¡¨æ–‡æœ¬ä¸»é¢˜çš„è¯è¯­
3. é¿å…åœç”¨è¯ï¼ˆå¦‚"çš„"ã€"æ˜¯"ã€"åœ¨"ç­‰ï¼‰
4. å¦‚æœæ˜¯ä»£ç ç‰‡æ®µï¼Œæå–å‡½æ•°åã€ç±»åã€æŠ€æœ¯æ ˆç­‰

æ–‡æœ¬ï¼š
"""
${text}
"""

è¯·ä»¥ JSON æ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "keywords": ["å…³é”®è¯1", "å…³é”®è¯2", "å…³é”®è¯3", ...],
  "confidence": 0.95
}`;
  }

  // æ‰¹é‡å¤„ç†ï¼ˆå¹¶å‘æ§åˆ¶ï¼‰
  async batchExtract(texts, topK = 5, concurrency = 3) {
    const results = [];
    for (let i = 0; i < texts.length; i += concurrency) {
      const batch = texts.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map(text => this.extract(text, topK))
      );
      results.push(...batchResults);
    }
    return results;
  }
}
```

#### Qwen ç³»ç»Ÿæç¤ºè¯æ¨¡æ¿

```javascript
const SYSTEM_PROMPTS = {
  // é€šç”¨å…³é”®è¯æå–
  general: `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä¸­æ–‡å…³é”®è¯æå–åŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯ï¼š
1. è¯†åˆ«æ–‡æœ¬ä¸­æœ€æ ¸å¿ƒçš„æ¦‚å¿µå’Œä¸»é¢˜
2. æå– 3-5 ä¸ªæœ€å…·ä»£è¡¨æ€§çš„å…³é”®è¯
3. å…³é”®è¯åº”ä¸ºåè¯ã€ä¸“ä¸šæœ¯è¯­æˆ–æ ¸å¿ƒæ¦‚å¿µ
4. é¿å…é€šç”¨åœç”¨è¯å’Œè™šè¯
5. ä»¥ JSON æ ¼å¼è¿”å›ç»“æœ`,

  // æŠ€æœ¯æ–‡æ¡£ä¸“ç”¨
  technical: `ä½ æ˜¯ä¸€ä¸ªæŠ€æœ¯æ–‡æ¡£å…³é”®è¯æå–ä¸“å®¶ã€‚è¯·å…³æ³¨ï¼š
1. æŠ€æœ¯æ ˆåç§°ï¼ˆReact, Node.js, TypeScript ç­‰ï¼‰
2. å‡½æ•°åã€ç±»åã€API åç§°
3. è®¾è®¡æ¨¡å¼å’Œæ¶æ„æ¦‚å¿µ
4. é”™è¯¯ä¿¡æ¯å’Œå…³é”®æ—¥å¿—
5. ä»¥ JSON æ ¼å¼è¿”å›ï¼Œæ ¼å¼ï¼š{"keywords": [...], "category": "æŠ€æœ¯/ä»£ç "}`,

  // é—®å·ç­”æ¡ˆä¸“ç”¨
  questionnaire: `ä½ æ˜¯é—®å·åˆ†æä¸“å®¶ã€‚ä»ç”¨æˆ·ç­”æ¡ˆä¸­æå–å…³é”®ä¿¡æ¯ï¼š
1. æƒ…æ„Ÿå€¾å‘è¯ï¼ˆæ»¡æ„ã€å›°æ‰°ã€æœŸå¾…ç­‰ï¼‰
2. å…·ä½“é—®é¢˜æè¿°
3. åŠŸèƒ½éœ€æ±‚å…³é”®è¯
4. åœºæ™¯æè¿°è¯
5. ä»¥ JSON æ ¼å¼è¿”å›ï¼Œæ ¼å¼ï¼š{"keywords": [...], "sentiment": "æ­£é¢/è´Ÿé¢/ä¸­æ€§"}`
};
```

#### é€‚ç”¨åœºæ™¯
- é•¿æ–‡æœ¬æ·±åº¦åˆ†æ
- éœ€è¦è¯­ä¹‰ç†è§£çš„åœºæ™¯
- è´¨é‡ä¼˜å…ˆï¼ˆéå®æ—¶ï¼‰
- å¤æ‚æ–‡æœ¬ç»“æ„ï¼ˆä»£ç  + æ³¨é‡Šï¼‰

#### æ€§èƒ½é¢„ä¼°
- **å•æ¡æ–‡æœ¬**ï¼š1-3 ç§’
- **100 æ¡æ–‡æœ¬**ï¼ˆå¹¶å‘3ï¼‰ï¼š30-60 ç§’
- **å†…å­˜/GPU æ¶ˆè€—**ï¼šå–å†³äº Qwen æ¨¡å‹å¤§å°

---

### æ–¹æ¡ˆ Dï¼šYAKEï¼ˆå¤šè¯­è¨€æ–¹æ¡ˆï¼‰â­â­â­

#### æŠ€æœ¯åŸç†
YAKE æ˜¯æ— ç›‘ç£çš„è½»é‡çº§å…³é”®è¯æå–ç®—æ³•ï¼ŒåŸºäºç»Ÿè®¡ç‰¹å¾ï¼ˆä½ç½®ã€é¢‘ç‡ã€ä¸Šä¸‹æ–‡ã€å¤§å°å†™ç­‰ï¼‰è¿›è¡Œæ‰“åˆ†ã€‚

#### ä¼˜ç‚¹
- âœ… **å¤šè¯­è¨€æ”¯æŒ**ï¼šæ— éœ€è¯­è¨€ç‰¹å®šè¯å…¸
- âœ… **æ— éœ€è®­ç»ƒ**ï¼šå¼€ç®±å³ç”¨
- âœ… **è½»é‡çº§**ï¼šèµ„æºæ¶ˆè€—ä½
- âœ… **å•æ–‡æ¡£æå–**ï¼šæ— éœ€æ–‡æ¡£é›†åˆ

#### ç¼ºç‚¹
- âš ï¸ **Node.js å®ç°å°‘**ï¼šä¸»è¦ä¸º Python
- âš ï¸ **WebAssembly ç‰ˆæœ¬**ï¼šæ€§èƒ½å¯èƒ½ä¸å¦‚åŸç”Ÿ
- âš ï¸ **ä¸­æ–‡æ•ˆæœä¸€èˆ¬**ï¼šæœªé’ˆå¯¹ä¸­æ–‡ä¼˜åŒ–

#### å®ç°æ­¥éª¤

```javascript
// ä½¿ç”¨ yake-wasmï¼ˆWebAssembly å®ç°ï¼‰
import { Yake } from 'yake-wasm';

async function extractWithYake(text, topK = 5) {
  const yake = await Yake.load();
  const keywords = yake.extract(text, {
    maxNgrams: 3,      // æœ€å¤§ N-gram é•¿åº¦
    deduplicationThreshold: 0.9,
    deduplicationAlgo: 'seqm',
    windowSize: 1,
    topK: topK
  });

  return keywords.map(kw => ({
    keyword: kw.text,
    score: kw.score  // åˆ†æ•°è¶Šä½è¶Šé‡è¦
  }));
}
```

#### é€‚ç”¨åœºæ™¯
- ä¸­è‹±æ–‡æ··åˆæ–‡æœ¬
- æ— æ³•ä½¿ç”¨ jieba çš„åœºæ™¯
- éœ€è¦å¤šè¯­è¨€ä¸€è‡´æ€§

---

## 3. Node.js å®ç°ä»£ç ç¤ºä¾‹

### 3.1 å®Œæ•´çš„å…³é”®è¯æå–æœåŠ¡

```javascript
// services/keyword-extraction-service.js

import { Jieba, TfIdf } from '@node-rs/jieba';
import { dict, idf } from '@node-rs/jieba/dict';
import axios from 'axios';

/**
 * å…³é”®è¯æå–æœåŠ¡
 * æ”¯æŒå¤šç§æå–ç­–ç•¥ï¼šTF-IDFã€TextRankã€LLM
 */
class KeywordExtractionService {
  constructor() {
    // åˆå§‹åŒ– jieba
    this.jieba = Jieba.withDict(dict);
    this.tfIdf = TfIdf.withDict(idf);

    // é…ç½®
    this.ollamaURL = process.env.OLLAMA_URL || 'http://localhost:11434';
    this.ollamaModel = process.env.OLLAMA_MODEL || 'qwen2.5:latest';

    // ä¸­æ–‡åœç”¨è¯
    this.stopwords = new Set([
      'çš„', 'äº†', 'åœ¨', 'æ˜¯', 'æˆ‘', 'æœ‰', 'å’Œ', 'å°±', 'ä¸', 'äºº',
      'éƒ½', 'ä¸€', 'ä¸€ä¸ª', 'ä¸Š', 'ä¹Ÿ', 'å¾ˆ', 'åˆ°', 'è¯´', 'è¦', 'å»',
      'ä½ ', 'ä¼š', 'ç€', 'æ²¡æœ‰', 'çœ‹', 'å¥½', 'è‡ªå·±', 'è¿™'
    ]);
  }

  /**
   * ä¸»å…¥å£ï¼šæ™ºèƒ½é€‰æ‹©æå–ç­–ç•¥
   * @param {string} text - æ–‡æœ¬å†…å®¹
   * @param {Object} options - é€‰é¡¹
   * @returns {Promise<Array<string>>} å…³é”®è¯æ•°ç»„
   */
  async extract(text, options = {}) {
    const {
      topK = 5,
      strategy = 'auto',  // auto | tfidf | textrank | llm
      minLength = 2,      // æœ€å°å…³é”®è¯é•¿åº¦
      filterStopwords = true
    } = options;

    // è‡ªåŠ¨é€‰æ‹©ç­–ç•¥
    let selectedStrategy = strategy;
    if (strategy === 'auto') {
      selectedStrategy = this.selectStrategy(text);
    }

    let keywords;
    switch (selectedStrategy) {
      case 'tfidf':
        keywords = this.extractWithTfIdf(text, topK);
        break;
      case 'textrank':
        keywords = await this.extractWithTextRank(text, topK);
        break;
      case 'llm':
        keywords = await this.extractWithLLM(text, topK);
        break;
      default:
        keywords = this.extractWithTfIdf(text, topK);
    }

    // åå¤„ç†
    return this.postProcess(keywords, { minLength, filterStopwords });
  }

  /**
   * ç­–ç•¥é€‰æ‹©é€»è¾‘
   */
  selectStrategy(text) {
    const length = text.length;

    // çŸ­æ–‡æœ¬ï¼ˆ< 100 å­—ï¼‰ï¼šTF-IDFï¼ˆå¿«é€Ÿï¼‰
    if (length < 100) return 'tfidf';

    // ä¸­ç­‰æ–‡æœ¬ï¼ˆ100-500 å­—ï¼‰ï¼šTextRankï¼ˆå¹³è¡¡ï¼‰
    if (length < 500) return 'textrank';

    // é•¿æ–‡æœ¬ï¼ˆ> 500 å­—ï¼‰ï¼šLLMï¼ˆé«˜è´¨é‡ï¼‰
    return 'llm';
  }

  /**
   * TF-IDF æå–
   */
  extractWithTfIdf(text, topK) {
    try {
      return this.tfIdf.extractKeywords(this.jieba, text, topK);
    } catch (error) {
      console.error('TF-IDF extraction failed:', error);
      return [];
    }
  }

  /**
   * TextRank æå–ï¼ˆç®€åŒ–å®ç°ï¼‰
   */
  async extractWithTextRank(text, topK) {
    // ä½¿ç”¨ nodejiebaï¼ˆå¦‚æœå·²å®‰è£…ï¼‰
    try {
      const nodejieba = await import('nodejieba');
      return nodejieba.textRankExtract(text, topK);
    } catch {
      // é™çº§åˆ° TF-IDF
      console.warn('TextRank not available, falling back to TF-IDF');
      return this.extractWithTfIdf(text, topK);
    }
  }

  /**
   * LLM æå–ï¼ˆOllamaï¼‰
   */
  async extractWithLLM(text, topK) {
    try {
      const response = await axios.post(`${this.ollamaURL}/api/generate`, {
        model: this.ollamaModel,
        prompt: this.buildLLMPrompt(text, topK),
        format: 'json',
        stream: false,
        options: {
          temperature: 0.3,
          top_p: 0.8,
          num_predict: 200
        }
      });

      const result = JSON.parse(response.data.response);
      return result.keywords || [];
    } catch (error) {
      console.error('LLM extraction failed:', error);
      // é™çº§åˆ° TF-IDF
      return this.extractWithTfIdf(text, topK);
    }
  }

  /**
   * æ„å»º LLM æç¤ºè¯
   */
  buildLLMPrompt(text, topK) {
    return `ä½ æ˜¯å…³é”®è¯æå–ä¸“å®¶ã€‚ä»ä»¥ä¸‹æ–‡æœ¬æå– ${topK} ä¸ªæ ¸å¿ƒå…³é”®è¯ã€‚

è¦æ±‚ï¼š
1. å…³é”®è¯åº”ä¸ºåè¯ã€æ ¸å¿ƒæ¦‚å¿µæˆ–ä¸“ä¸šæœ¯è¯­
2. ä¼˜å…ˆé€‰æ‹©èƒ½ä»£è¡¨ä¸»é¢˜çš„è¯è¯­
3. é¿å…åœç”¨è¯
4. æŒ‰é‡è¦æ€§æ’åº

æ–‡æœ¬ï¼š
"""
${text.slice(0, 2000)}
"""

ä»¥ JSON æ ¼å¼è¿”å›ï¼š{"keywords": ["è¯1", "è¯2", ...]}`;
  }

  /**
   * åå¤„ç†ï¼šè¿‡æ»¤å’Œæ¸…ç†
   */
  postProcess(keywords, { minLength, filterStopwords }) {
    return keywords
      .filter(kw => {
        // å»é™¤ç©ºå€¼
        if (!kw || typeof kw !== 'string') return false;

        // é•¿åº¦è¿‡æ»¤
        if (kw.length < minLength) return false;

        // åœç”¨è¯è¿‡æ»¤
        if (filterStopwords && this.stopwords.has(kw)) return false;

        // å»é™¤çº¯æ•°å­—
        if (/^\d+$/.test(kw)) return false;

        return true;
      })
      .map(kw => kw.trim())
      .filter((kw, index, self) => self.indexOf(kw) === index); // å»é‡
  }

  /**
   * æ‰¹é‡æå–ï¼ˆå¸¦è¿›åº¦å›è°ƒï¼‰
   */
  async batchExtract(documents, options = {}, onProgress = null) {
    const results = [];
    const total = documents.length;

    for (let i = 0; i < total; i++) {
      const keywords = await this.extract(documents[i], options);
      results.push({
        index: i,
        text: documents[i],
        keywords
      });

      if (onProgress) {
        onProgress({
          current: i + 1,
          total,
          percentage: ((i + 1) / total * 100).toFixed(2)
        });
      }
    }

    return results;
  }
}

export default KeywordExtractionService;
```

### 3.2 ä¸ RAG ç³»ç»Ÿé›†æˆ

```javascript
// services/embedding-service.js (æ‰©å±•)

import KeywordExtractionService from './keyword-extraction-service.js';
import Database from 'better-sqlite3';

class RAGEmbeddingService {
  constructor(dbPath) {
    this.db = new Database(dbPath);
    this.keywordExtractor = new KeywordExtractionService();
    this.initDatabase();
  }

  initDatabase() {
    // åˆ›å»ºçŸ¥è¯†åº“è¡¨ï¼ˆåŒ…å«å…³é”®è¯å­—æ®µï¼‰
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS knowledge_base (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        content TEXT NOT NULL,
        embedding BLOB NOT NULL,
        keywords TEXT,  -- JSON æ•°ç»„
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      -- å…¨æ–‡æœç´¢ç´¢å¼•ï¼ˆFTS5ï¼‰
      CREATE VIRTUAL TABLE IF NOT EXISTS knowledge_base_fts
      USING fts5(
        content,
        keywords,
        content='knowledge_base',
        content_rowid='id',
        tokenize='unicode61'
      );

      -- è§¦å‘å™¨ï¼šè‡ªåŠ¨åŒæ­¥åˆ° FTS
      CREATE TRIGGER IF NOT EXISTS knowledge_base_ai
      AFTER INSERT ON knowledge_base BEGIN
        INSERT INTO knowledge_base_fts(rowid, content, keywords)
        VALUES (new.id, new.content, new.keywords);
      END;
    `);
  }

  /**
   * æ·»åŠ çŸ¥è¯†æ¡ç›®ï¼ˆè‡ªåŠ¨æå–å…³é”®è¯ï¼‰
   */
  async addKnowledge(content) {
    // 1. æå–å…³é”®è¯
    const keywords = await this.keywordExtractor.extract(content, {
      topK: 5,
      strategy: 'auto'
    });

    // 2. ç”ŸæˆåµŒå…¥å‘é‡
    const embedding = await this.generateEmbedding(content);

    // 3. å­˜å‚¨
    const stmt = this.db.prepare(`
      INSERT INTO knowledge_base (content, embedding, keywords)
      VALUES (?, ?, ?)
    `);

    const result = stmt.run(
      content,
      Buffer.from(new Float32Array(embedding).buffer),
      JSON.stringify(keywords)
    );

    return {
      id: result.lastInsertRowid,
      content,
      keywords,
      embedding
    };
  }

  /**
   * æ··åˆæ£€ç´¢ï¼šå…³é”®è¯ (BM25) + å‘é‡
   */
  async hybridSearch(query, options = {}) {
    const {
      topK = 10,
      alpha = 0.7,  // è¯­ä¹‰æœç´¢æƒé‡ï¼ˆ0-1ï¼‰
      beta = 0.3    // å…³é”®è¯æœç´¢æƒé‡ï¼ˆ1-alphaï¼‰
    } = options;

    // 1. æå–æŸ¥è¯¢å…³é”®è¯
    const queryKeywords = await this.keywordExtractor.extract(query, {
      topK: 3,
      strategy: 'tfidf'  // æŸ¥è¯¢ç”¨å¿«é€Ÿç­–ç•¥
    });

    // 2. BM25 å…³é”®è¯æœç´¢
    const keywordResults = this.keywordSearch(queryKeywords, topK * 2);

    // 3. å‘é‡è¯­ä¹‰æœç´¢
    const vectorResults = await this.vectorSearch(query, topK * 2);

    // 4. èåˆæ’åºï¼ˆRRF - Reciprocal Rank Fusionï¼‰
    const fusedResults = this.fuseResults(
      keywordResults,
      vectorResults,
      { alpha, beta, topK }
    );

    return fusedResults;
  }

  /**
   * å…³é”®è¯æœç´¢ï¼ˆBM25ï¼‰
   */
  keywordSearch(keywords, limit) {
    const keywordQuery = keywords.join(' OR ');

    const stmt = this.db.prepare(`
      SELECT
        kb.id,
        kb.content,
        kb.keywords,
        fts.rank as bm25_score
      FROM knowledge_base_fts fts
      JOIN knowledge_base kb ON fts.rowid = kb.id
      WHERE knowledge_base_fts MATCH ?
      ORDER BY rank
      LIMIT ?
    `);

    return stmt.all(keywordQuery, limit);
  }

  /**
   * å‘é‡æœç´¢ï¼ˆä½™å¼¦ç›¸ä¼¼åº¦ï¼‰
   */
  async vectorSearch(query, limit) {
    const queryEmbedding = await this.generateEmbedding(query);

    // è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦ï¼ˆç®€åŒ–å®ç°ï¼‰
    const allDocs = this.db.prepare('SELECT * FROM knowledge_base').all();

    const scored = allDocs.map(doc => {
      const docEmbedding = new Float32Array(doc.embedding);
      const similarity = this.cosineSimilarity(queryEmbedding, docEmbedding);
      return { ...doc, vector_score: similarity };
    });

    return scored
      .sort((a, b) => b.vector_score - a.vector_score)
      .slice(0, limit);
  }

  /**
   * ç»“æœèåˆï¼ˆRRFï¼‰
   */
  fuseResults(keywordResults, vectorResults, { alpha, beta, topK }) {
    const scoreMap = new Map();

    // å…³é”®è¯ç»“æœæ‰“åˆ†
    keywordResults.forEach((result, index) => {
      const rrfScore = 1 / (60 + index + 1); // RRF å…¬å¼
      scoreMap.set(result.id, {
        ...result,
        keyword_rrf: rrfScore,
        vector_rrf: 0
      });
    });

    // å‘é‡ç»“æœæ‰“åˆ†
    vectorResults.forEach((result, index) => {
      const rrfScore = 1 / (60 + index + 1);
      if (scoreMap.has(result.id)) {
        scoreMap.get(result.id).vector_rrf = rrfScore;
      } else {
        scoreMap.set(result.id, {
          ...result,
          keyword_rrf: 0,
          vector_rrf: rrfScore
        });
      }
    });

    // åŠ æƒèåˆ
    const fused = Array.from(scoreMap.values()).map(item => ({
      ...item,
      final_score: (beta * item.keyword_rrf) + (alpha * item.vector_rrf)
    }));

    return fused
      .sort((a, b) => b.final_score - a.final_score)
      .slice(0, topK);
  }

  /**
   * ä½™å¼¦ç›¸ä¼¼åº¦è®¡ç®—
   */
  cosineSimilarity(vecA, vecB) {
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }

    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  /**
   * ç”ŸæˆåµŒå…¥å‘é‡ï¼ˆè°ƒç”¨ Ollamaï¼‰
   */
  async generateEmbedding(text) {
    // ... ç°æœ‰å®ç°
  }
}

export default RAGEmbeddingService;
```

### 3.3 ä½¿ç”¨ç¤ºä¾‹

```javascript
// scripts/test-keyword-extraction.js

import KeywordExtractionService from '../services/keyword-extraction-service.js';
import RAGEmbeddingService from '../services/embedding-service.js';

async function testKeywordExtraction() {
  const extractor = new KeywordExtractionService();

  // æµ‹è¯•æ–‡æœ¬
  const texts = [
    'ä»Šå¤©å­¦ä¹ äº† React çš„ Hooks ä½¿ç”¨æ–¹æ³•ï¼ŒåŒ…æ‹¬ useState å’Œ useEffectã€‚',
    'é¡¹ç›®ä¸­é‡åˆ°äº†è·¨åŸŸé—®é¢˜ï¼Œé€šè¿‡é…ç½® CORS è§£å†³äº†ã€‚ä½¿ç”¨äº† Express ä¸­é—´ä»¶ã€‚',
    'ç”¨æˆ·åé¦ˆç™»å½•åŠŸèƒ½æœ‰ Bugï¼Œåœ¨ Safari æµè§ˆå™¨ä¸Šæ— æ³•æ­£å¸¸å·¥ä½œã€‚'
  ];

  console.log('=== æµ‹è¯•ä¸åŒç­–ç•¥ ===\n');

  for (const text of texts) {
    console.log(`æ–‡æœ¬ï¼š${text}`);

    // TF-IDF
    const tfidfKeywords = await extractor.extract(text, { strategy: 'tfidf', topK: 3 });
    console.log('TF-IDF:', tfidfKeywords);

    // TextRank
    const textrankKeywords = await extractor.extract(text, { strategy: 'textrank', topK: 3 });
    console.log('TextRank:', textrankKeywords);

    // LLM
    const llmKeywords = await extractor.extract(text, { strategy: 'llm', topK: 3 });
    console.log('LLM:', llmKeywords);

    console.log('---\n');
  }
}

async function testRAGIntegration() {
  const rag = new RAGEmbeddingService('./data/rag-database.db');

  // æ·»åŠ çŸ¥è¯†ï¼ˆè‡ªåŠ¨æå–å…³é”®è¯ï¼‰
  await rag.addKnowledge('React Hooks æ˜¯ React 16.8 å¼•å…¥çš„æ–°ç‰¹æ€§ï¼Œå…è®¸åœ¨å‡½æ•°ç»„ä»¶ä¸­ä½¿ç”¨çŠ¶æ€å’Œå…¶ä»– React ç‰¹æ€§ã€‚');

  // æ··åˆæ£€ç´¢
  const results = await rag.hybridSearch('å¦‚ä½•ä½¿ç”¨ React Hooksï¼Ÿ', {
    topK: 5,
    alpha: 0.7  // 70% è¯­ä¹‰ï¼Œ30% å…³é”®è¯
  });

  console.log('æ··åˆæ£€ç´¢ç»“æœï¼š', results);
}

// è¿è¡Œæµ‹è¯•
testKeywordExtraction();
testRAGIntegration();
```

---

## 4. æ€§èƒ½è¯„ä¼°

### 4.1 é€Ÿåº¦å¯¹æ¯”æµ‹è¯•

åŸºäºè°ƒç ”æ•°æ®å’ŒåŸºå‡†æµ‹è¯•ï¼Œä»¥ä¸‹æ˜¯å„æ–¹æ¡ˆåœ¨å¤„ç† **100 æ¡ä¸­æ–‡æ–‡æœ¬**ï¼ˆå¹³å‡ 200 å­—ï¼‰æ—¶çš„æ€§èƒ½ï¼š

| æ–¹æ¡ˆ | å•æ¡è€—æ—¶ | 100æ¡æ€»è€—æ—¶ | 1000æ¡æ€»è€—æ—¶ | å†…å­˜å ç”¨ | å¤‡æ³¨ |
|------|---------|------------|-------------|---------|------|
| **TF-IDF (@node-rs/jieba)** | < 10ms | < 1s | < 10s | 50-80MB | æœ€å¿«æ–¹æ¡ˆ |
| **RAKE** | < 4ms | < 0.5s | < 5s | 30-50MB | è‹±æ–‡æå¿« |
| **TextRank (nodejieba)** | 20ms | 2s | 20s | 80-120MB | ä¸­ç­‰é€Ÿåº¦ |
| **YAKE (WASM)** | 15ms | 1.5s | 15s | 60-100MB | è¾ƒå¿« |
| **KeyBERT** | 500-1000ms | 50-100s | 500-1000s | 500MB-2GB | éœ€ GPU åŠ é€Ÿ |
| **Ollama + Qwen (7B)** | 1-3s | 100-300s | 1000-3000s | 2-4GB | å¹¶å‘å¯ä¼˜åŒ– |

### 4.2 å‡†ç¡®ç‡å¯¹æ¯”

åŸºäºæ–‡çŒ®å’Œç¤¾åŒºåé¦ˆï¼š

| æ–¹æ¡ˆ | å‡†ç¡®ç‡ (F1 Score) | è¯­ä¹‰ç†è§£ | ä¸­æ–‡æ”¯æŒ | ç»¼åˆè¯„åˆ† |
|------|------------------|---------|---------|---------|
| **TF-IDF** | 0.65-0.75 | â­â­ | â­â­â­ (éœ€åˆ†è¯) | â­â­â­ |
| **RAKE** | 0.70-0.80 | â­â­â­ | â­â­ (è‹±æ–‡ä¼˜åŒ–) | â­â­â­ |
| **TextRank** | 0.75-0.85 | â­â­â­â­ | â­â­â­â­ (é…åˆjieba) | â­â­â­â­ |
| **YAKE** | 0.75-0.85 | â­â­â­â­ | â­â­â­ (é€šç”¨) | â­â­â­â­ |
| **KeyBERT** | 0.85-0.92 | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **Ollama + Qwen** | 0.88-0.95 | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |

### 4.3 èµ„æºæ¶ˆè€—å¯¹æ¯”

| æ–¹æ¡ˆ | åˆå§‹åŒ–æ—¶é—´ | å†…å­˜å³°å€¼ | CPU å ç”¨ | GPU éœ€æ±‚ | ç£ç›˜ç©ºé—´ |
|------|----------|---------|---------|---------|---------|
| **@node-rs/jieba** | < 100ms | 80MB | ä½ | æ—  | 40MB (è¯å…¸) |
| **RAKE** | < 10ms | 30MB | ä½ | æ—  | < 1MB |
| **TextRank** | < 100ms | 120MB | ä¸­ | æ—  | 40MB (è¯å…¸) |
| **YAKE (WASM)** | 200-500ms | 100MB | ä¸­ | æ—  | 5MB |
| **KeyBERT** | 2-5s | 2GB | é«˜ | æ¨è | 500MB (æ¨¡å‹) |
| **Ollama + Qwen** | å·²è¿è¡Œ | 4GB | é«˜ | æ¨è | å·²éƒ¨ç½² |

### 4.4 å®é™…åœºæ™¯æ€§èƒ½æµ‹è¯•å»ºè®®

```javascript
// scripts/benchmark-keyword-extraction.js

async function benchmark() {
  const testData = [
    { size: 100, text: 'çŸ­æ–‡æœ¬æµ‹è¯•' },
    { size: 500, text: 'ä¸­ç­‰é•¿åº¦æŠ€æœ¯æ–‡æ¡£æµ‹è¯•...' },
    { size: 2000, text: 'é•¿æ–‡ç« æµ‹è¯•...' }
  ];

  const strategies = ['tfidf', 'textrank', 'llm'];
  const results = [];

  for (const data of testData) {
    for (const strategy of strategies) {
      const start = performance.now();

      await extractor.extract(data.text, { strategy, topK: 5 });

      const elapsed = performance.now() - start;
      const memory = process.memoryUsage();

      results.push({
        textSize: data.size,
        strategy,
        time: elapsed.toFixed(2) + 'ms',
        memory: (memory.heapUsed / 1024 / 1024).toFixed(2) + 'MB'
      });
    }
  }

  console.table(results);
}
```

---

## 5. æ¨èå†³ç­–

### 5.1 æœ€ç»ˆæ¨èæ–¹æ¡ˆ

åŸºäºå£®çˆ¸çš„ RAG ç³»ç»Ÿéœ€æ±‚ï¼ˆæœ¬åœ°åŒ–ã€ä¸­æ–‡æ”¯æŒã€Node.jsã€ä¸ Ollama é›†æˆï¼‰ï¼Œæˆ‘æ¨èé‡‡ç”¨ **æ··åˆç­–ç•¥**ï¼š

#### ğŸ† ä¸»æ¨æ–¹æ¡ˆï¼š**@node-rs/jieba + TF-IDF/TextRank**

**ç†ç”±**ï¼š
1. âœ… **å®Œå…¨ç¬¦åˆæŠ€æœ¯æ ˆ**ï¼šNode.js åŸç”Ÿï¼Œæ— éœ€ Python
2. âœ… **æœ¬åœ°åŒ–è¿è¡Œ**ï¼šæ— å¤–éƒ¨ä¾èµ–
3. âœ… **ä¸­æ–‡ä¼˜åŒ–**ï¼šä¸“ä¸ºä¸­æ–‡è®¾è®¡
4. âœ… **æ€§èƒ½ä¼˜å¼‚**ï¼šé€Ÿåº¦å¿«ã€èµ„æºæ¶ˆè€—ä½
5. âœ… **æ˜“äºç»´æŠ¤**ï¼šä»£ç ç®€å•ã€ç¤¾åŒºæ´»è·ƒ
6. âœ… **é€‚åˆæ‰¹é‡å¤„ç†**ï¼šå¯å¿«é€Ÿå¤„ç†å¤§é‡æ–‡æœ¬

**ä½¿ç”¨åœºæ™¯**ï¼š
- ç”¨æˆ·é—®å·ç­”æ¡ˆå…¥åº“ï¼ˆè‡ªåŠ¨æå–å…³é”®è¯ï¼‰
- é¡¹ç›®æ€»ç»“å…³é”®è¯ç”Ÿæˆ
- å®æ—¶æŸ¥è¯¢å…³é”®è¯æå–

#### ğŸ¥ˆ è¾…åŠ©æ–¹æ¡ˆï¼š**Ollama + Qwen æç¤ºè¯å·¥ç¨‹**

**ç†ç”±**ï¼š
1. âœ… **åˆ©ç”¨ç°æœ‰åŸºç¡€è®¾æ–½**ï¼šé¡¹ç›®å·²éƒ¨ç½² Ollama
2. âœ… **æœ€é«˜è´¨é‡**ï¼šæ·±åº¦è¯­ä¹‰ç†è§£
3. âœ… **çµæ´»å¯å®šåˆ¶**ï¼šé€šè¿‡æç¤ºè¯è°ƒæ•´ç­–ç•¥
4. âœ… **ä¸­æ–‡ä¼˜åŒ–**ï¼šQwen å¯¹ä¸­æ–‡æ”¯æŒå“è¶Š

**ä½¿ç”¨åœºæ™¯**ï¼š
- é•¿æ–‡æ¡£æ·±åº¦åˆ†æ
- ä»£ç ç‰‡æ®µå…³é”®è¯æå–
- è´¨é‡è¦æ±‚é«˜çš„åœºæ™¯
- ç¦»çº¿æ‰¹å¤„ç†ï¼ˆéå®æ—¶ï¼‰

### 5.2 ç»„åˆç­–ç•¥å®æ–½æ–¹æ¡ˆ

```javascript
class HybridKeywordExtractor {
  async extract(text, context = {}) {
    const length = text.length;
    const { quality = 'balanced', realtime = true } = context;

    // å†³ç­–æ ‘
    if (realtime && length < 500) {
      // å®æ—¶çŸ­æ–‡æœ¬ â†’ TF-IDFï¼ˆé€Ÿåº¦ä¼˜å…ˆï¼‰
      return this.extractWithTfIdf(text);
    }

    if (quality === 'high' || length > 1000) {
      // é«˜è´¨é‡é•¿æ–‡æœ¬ â†’ LLMï¼ˆå‡†ç¡®ç‡ä¼˜å…ˆï¼‰
      return this.extractWithLLM(text);
    }

    // é»˜è®¤ â†’ TextRankï¼ˆå¹³è¡¡ï¼‰
    return this.extractWithTextRank(text);
  }
}
```

### 5.3 å…³é”®å‚æ•°é…ç½®å»ºè®®

#### å…³é”®è¯æ•°é‡ï¼ˆtopKï¼‰
- **æŸ¥è¯¢æ–‡æœ¬**ï¼š3 ä¸ªå…³é”®è¯ï¼ˆå¿«é€ŸåŒ¹é…ï¼‰
- **çŸ­æ–‡æœ¬ï¼ˆ< 200 å­—ï¼‰**ï¼š3-5 ä¸ªå…³é”®è¯
- **ä¸­æ–‡æœ¬ï¼ˆ200-500 å­—ï¼‰**ï¼š5-7 ä¸ªå…³é”®è¯
- **é•¿æ–‡æœ¬ï¼ˆ> 500 å­—ï¼‰**ï¼š7-10 ä¸ªå…³é”®è¯

#### æ··åˆæ£€ç´¢æƒé‡ï¼ˆalphaï¼‰
- **ç²¾ç¡®åŒ¹é…ä¼˜å…ˆ**ï¼šalpha = 0.3-0.5ï¼ˆå…³é”®è¯æƒé‡é«˜ï¼‰
- **å¹³è¡¡æœç´¢**ï¼šalpha = 0.6-0.7ï¼ˆæ¨èï¼‰
- **è¯­ä¹‰ç†è§£ä¼˜å…ˆ**ï¼šalpha = 0.8-0.9ï¼ˆå‘é‡æƒé‡é«˜ï¼‰

#### æœ€å°å…³é”®è¯é•¿åº¦
- **ä¸­æ–‡**ï¼šminLength = 2ï¼ˆåŒå­—è¯ï¼‰
- **è‹±æ–‡**ï¼šminLength = 3ï¼ˆé¿å…å† è¯ç­‰ï¼‰

### 5.4 å®æ–½è·¯çº¿å›¾

#### Phase 1ï¼šåŸºç¡€å®æ–½ï¼ˆ1-2 å¤©ï¼‰
- [ ] å®‰è£… `@node-rs/jieba`
- [ ] å®ç° `KeywordExtractionService` åŸºç¡€ç±»
- [ ] é›†æˆåˆ°ç°æœ‰ `embedding-service.js`
- [ ] æ‰©å±•æ•°æ®åº“ Schemaï¼ˆæ·»åŠ  keywords å­—æ®µï¼‰
- [ ] å®ç°è‡ªåŠ¨å…³é”®è¯æå–

#### Phase 2ï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆ1 å¤©ï¼‰
- [ ] æ·»åŠ  SQLite FTS5 å…¨æ–‡ç´¢å¼•
- [ ] å®ç° BM25 å…³é”®è¯æœç´¢
- [ ] å®ç°æ··åˆæ£€ç´¢ï¼ˆRRF èåˆï¼‰
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•

#### Phase 3ï¼šé«˜çº§åŠŸèƒ½ï¼ˆ1-2 å¤©ï¼‰
- [ ] é›†æˆ Ollama LLM æå–
- [ ] å®ç°æ™ºèƒ½ç­–ç•¥é€‰æ‹©
- [ ] æ·»åŠ æ‰¹é‡å¤„ç†å’Œè¿›åº¦å›è°ƒ
- [ ] ä¼˜åŒ–åœç”¨è¯å’Œåå¤„ç†

#### Phase 4ï¼šæµ‹è¯•ä¸è°ƒä¼˜ï¼ˆ1 å¤©ï¼‰
- [ ] çœŸå®æ•°æ®æµ‹è¯•
- [ ] è°ƒæ•´ alpha æƒé‡
- [ ] ä¼˜åŒ–å…³é”®è¯æ•°é‡
- [ ] æ–‡æ¡£å’Œç¤ºä¾‹

### 5.5 é£é™©ä¸åº”å¯¹

| é£é™© | æ¦‚ç‡ | å½±å“ | åº”å¯¹æªæ–½ |
|------|------|------|---------|
| jieba ä¸­æ–‡åˆ†è¯ä¸å‡†ç¡® | ä¸­ | ä¸­ | 1. è‡ªå®šä¹‰è¯å…¸<br>2. é™çº§åˆ° LLM |
| å…³é”®è¯å™ªå£°è¿‡å¤š | ä¸­ | ä¸­ | 1. ä¼˜åŒ–åœç”¨è¯<br>2. æé«˜ minLength |
| LLM æå–é€Ÿåº¦æ…¢ | é«˜ | ä½ | 1. ä»…ç”¨äºç¦»çº¿æ‰¹å¤„ç†<br>2. å¹¶å‘æ§åˆ¶ |
| FTS5 ä¸­æ–‡åˆ†è¯é—®é¢˜ | ä¸­ | ä¸­ | 1. ä½¿ç”¨ unicode61 tokenizer<br>2. é¢„å¤„ç†å…³é”®è¯ |

---

## 6. å‚è€ƒèµ„æº

### 6.1 æ ¸å¿ƒåº“å’Œå·¥å…·

#### Node.js åº“
- **@node-rs/jieba**
  - GitHub: https://github.com/Brooooooklyn/node-rs
  - npm: https://www.npmjs.com/package/@node-rs/jieba
  - æ–‡æ¡£: Rust ç»‘å®šï¼Œæ€§èƒ½ä¼˜å¼‚

- **nodejieba**
  - GitHub: https://github.com/yanyiwu/nodejieba
  - npm: https://www.npmjs.com/package/nodejieba
  - æ–‡æ¡£: ä¼ ç»Ÿ C++ ç»‘å®šï¼Œæ”¯æŒ TextRank

- **natural**
  - GitHub: https://github.com/NaturalNode/natural
  - æ–‡æ¡£: https://naturalnode.github.io/natural/
  - åŠŸèƒ½: TF-IDFã€åˆ†è¯ã€åˆ†ç±»ç­‰

- **yake-wasm**
  - npm: https://www.npmjs.com/package/yake-wasm
  - å®˜ç½‘: https://liaad.github.io/yake/
  - ç‰¹ç‚¹: WebAssembly å®ç°ï¼Œå¤šè¯­è¨€

#### Python åº“ï¼ˆå‚è€ƒï¼‰
- **KeyBERT**: https://github.com/MaartenGr/KeyBERT
- **YAKE**: https://github.com/LIAAD/yake
- **PKE**: https://github.com/boudinfl/pke

### 6.2 æŠ€æœ¯æ–‡ç« å’Œæ•™ç¨‹

#### å…³é”®è¯æå–ç»¼è¿°
1. **"Keyword Extraction - A Benchmark of 7 Algorithms in Python"**
   - é“¾æ¥: https://towardsdatascience.com/keyword-extraction-a-benchmark-of-7-algorithms-in-python-8a905326d93f/
   - å†…å®¹: 7 ç§ç®—æ³•æ€§èƒ½å¯¹æ¯”

2. **"Automated Keyword Extraction â€“ TF-IDF, RAKE, and TextRank"**
   - é“¾æ¥: https://www.tiernok.com/posts/automated-keyword-extraction-tf-idf-rake-and-textrank.html
   - å†…å®¹: ä¸‰ç§ç®—æ³•è¯¦ç»†å¯¹æ¯”

3. **"A Review of Keyphrase Extraction"**
   - arXiv: https://arxiv.org/pdf/1905.05044
   - å†…å®¹: å­¦æœ¯ç»¼è¿°è®ºæ–‡

#### æ··åˆæ£€ç´¢å®è·µ
4. **"Hybrid Search: Combining BM25 and Semantic Search"**
   - é“¾æ¥: https://medium.com/etoai/hybrid-search-combining-bm25-and-semantic-search-for-better-results-with-lan-1358038fe7e6
   - å†…å®¹: BM25 + å‘é‡æ··åˆæ£€ç´¢

5. **"Optimizing RAG with Hybrid Search & Reranking"**
   - é“¾æ¥: https://superlinked.com/vectorhub/articles/optimizing-rag-with-hybrid-search-reranking
   - å†…å®¹: RAG ä¼˜åŒ–å®è·µ

#### ä¸­æ–‡ NLP
6. **"Chinese Word Segmentation with Jieba"**
   - é“¾æ¥: https://alvinntnu.github.io/python-notes/corpus/jieba.html
   - å†…å®¹: Jieba ä½¿ç”¨æ•™ç¨‹

7. **"Chinese Text Processing"**
   - é“¾æ¥: https://alvinntnu.github.io/NTNU_ENC2036_LECTURES/chinese-text-processing.html
   - å†…å®¹: ä¸­æ–‡æ–‡æœ¬å¤„ç†ç»¼è¿°

#### Ollama é›†æˆ
8. **"Structured Outputs with Ollama"**
   - é“¾æ¥: https://ollama.com/blog/structured-outputs
   - å†…å®¹: JSON æ ¼å¼åŒ–è¾“å‡º

9. **"Prompt Engineering with Qwen"**
   - GitHub: https://github.com/QwenLM/Qwen/blob/main/examples/system_prompt.md
   - å†…å®¹: Qwen æç¤ºè¯å·¥ç¨‹

### 6.3 å¼€æºé¡¹ç›®æ¡ˆä¾‹

#### RAG ç³»ç»Ÿå‚è€ƒ
- **LangChain RAG å®ç°**: https://js.langchain.com/docs/tutorials/rag
- **Weaviate Hybrid Search**: https://weaviate.io/blog/hybrid-search-explained
- **Pinecone Hybrid Search**: https://www.pinecone.io/learn/hybrid-search-intro/

#### ä¸­æ–‡å…³é”®è¯æå–
- **chinese_keyphrase_extractor**: https://github.com/dongrixinyu/chinese_keyphrase_extractor
- **KeyExtractor**: https://github.com/allenyummy/KeyExtractor

### 6.4 æ•°æ®åº“å’Œç´¢å¼•

#### SQLite FTS5
- **å®˜æ–¹æ–‡æ¡£**: https://www.sqlite.org/fts5.html
- **å®è·µæŒ‡å—**: https://medium.com/@johnidouglasmarangon/full-text-search-in-sqlite-a-practical-guide-80a69c3f42a4

#### Better-SQLite3
- **GitHub**: https://github.com/WiseLibs/better-sqlite3
- **æ–‡æ¡£**: æ€§èƒ½æœ€ä½³çš„ SQLite Node.js ç»‘å®š

### 6.5 å­¦æœ¯è®ºæ–‡

1. **TextRank: Bringing Order into Texts**
   - ä½œè€…: Rada Mihalcea, Paul Tarau
   - å†…å®¹: TextRank ç®—æ³•åŸè®ºæ–‡

2. **YAKE! Keyword Extraction from Single Documents**
   - é“¾æ¥: http://yake.inesctec.pt/
   - å†…å®¹: YAKE ç®—æ³•è®ºæ–‡

3. **Automatic Keyword Extraction from Individual Documents**
   - å†…å®¹: RAKE ç®—æ³•åŸè®ºæ–‡

---

## é™„å½•

### A. ä¸­æ–‡åœç”¨è¯è¡¨ç¤ºä¾‹

```javascript
const CHINESE_STOPWORDS = [
  // ä»£è¯
  'æˆ‘', 'ä½ ', 'ä»–', 'å¥¹', 'å®ƒ', 'æˆ‘ä»¬', 'ä½ ä»¬', 'ä»–ä»¬', 'å¥¹ä»¬',
  'è‡ªå·±', 'äººå®¶', 'å’±ä»¬', 'è¿™', 'é‚£', 'è¿™ä¸ª', 'é‚£ä¸ª', 'è¿™äº›', 'é‚£äº›',

  // åŠ©è¯
  'çš„', 'äº†', 'å—', 'å‘¢', 'å§', 'å•Š', 'å‘€', 'å•¦', 'å˜›', 'ç€', 'è¿‡',

  // è¿è¯
  'å’Œ', 'ä¸', 'æˆ–', 'ä½†', 'è€Œ', 'å› ä¸º', 'æ‰€ä»¥', 'å¦‚æœ', 'è™½ç„¶', 'ä½†æ˜¯',

  // ä»‹è¯
  'åœ¨', 'äº', 'ä»', 'å¯¹', 'å‘', 'å¾€', 'åˆ°', 'æŠŠ', 'è¢«', 'ç»™',

  // åŠ¨è¯ï¼ˆå¸¸ç”¨ï¼‰
  'æ˜¯', 'æœ‰', 'ä¼š', 'èƒ½', 'è¦', 'å¯ä»¥', 'åº”è¯¥', 'å¿…é¡»', 'åš', 'è¯´',

  // å‰¯è¯
  'å¾ˆ', 'éå¸¸', 'ååˆ†', 'ç‰¹åˆ«', 'æ¯”è¾ƒ', 'å¤ª', 'æ›´', 'æœ€', 'éƒ½', 'ä¹Ÿ',

  // æ•°é‡è¯
  'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å',
  'ä¸ª', 'äº›', 'å¤š', 'å°‘', 'å‡ ', 'ç¬¬',

  // æ ‡ç‚¹ç¬¦å·
  'ï¼Œ', 'ã€‚', 'ï¼', 'ï¼Ÿ', 'ï¼›', 'ï¼š', '"', '"', ''', ''', 'ã€',
  'ã€Š', 'ã€‹', 'ã€ˆ', 'ã€‰', 'ã€', 'ã€‘', 'ï¼ˆ', 'ï¼‰', 'ï¼»', 'ï¼½'
];
```

### B. Qwen æç¤ºè¯æ¨¡æ¿å®Œæ•´ç‰ˆ

```javascript
const PROMPT_TEMPLATES = {
  general: {
    system: `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä¸­æ–‡å…³é”®è¯æå–åŠ©æ‰‹ã€‚`,
    user: (text, topK) => `ä»ä»¥ä¸‹æ–‡æœ¬ä¸­æå– ${topK} ä¸ªæœ€æ ¸å¿ƒçš„å…³é”®è¯ï¼š

è¦æ±‚ï¼š
1. å…³é”®è¯åº”ä¸ºåè¯ã€æ ¸å¿ƒæ¦‚å¿µæˆ–ä¸“ä¸šæœ¯è¯­
2. ä¼˜å…ˆé€‰æ‹©èƒ½ä»£è¡¨æ–‡æœ¬ä¸»é¢˜çš„è¯è¯­
3. é¿å…åœç”¨è¯ï¼ˆå¦‚"çš„"ã€"æ˜¯"ã€"åœ¨"ç­‰ï¼‰
4. æŒ‰é‡è¦æ€§æ’åº

æ–‡æœ¬ï¼š
"""
${text}
"""

è¯·ä»¥ JSON æ ¼å¼è¿”å›ï¼Œæ ¼å¼ï¼š
{
  "keywords": ["å…³é”®è¯1", "å…³é”®è¯2", ...],
  "confidence": 0.95
}`
  },

  technical: {
    system: `ä½ æ˜¯æŠ€æœ¯æ–‡æ¡£åˆ†æä¸“å®¶ï¼Œæ“…é•¿è¯†åˆ«ç¼–ç¨‹è¯­è¨€ã€æ¡†æ¶ã€å‡½æ•°åã€è®¾è®¡æ¨¡å¼ç­‰æŠ€æœ¯æœ¯è¯­ã€‚`,
    user: (text, topK) => `ä»ä»¥ä¸‹æŠ€æœ¯æ–‡æœ¬ä¸­æå– ${topK} ä¸ªå…³é”®è¯ï¼š

å…³æ³¨ç‚¹ï¼š
1. ç¼–ç¨‹è¯­è¨€ï¼ˆPython, JavaScript, TypeScript ç­‰ï¼‰
2. æ¡†æ¶å’Œåº“ï¼ˆReact, Vue, Express ç­‰ï¼‰
3. å‡½æ•°åã€ç±»åã€API åç§°
4. è®¾è®¡æ¨¡å¼å’Œæ¶æ„æ¦‚å¿µ
5. é”™è¯¯ä¿¡æ¯å’Œå…³é”®æ—¥å¿—

æ–‡æœ¬ï¼š
"""
${text}
"""

ä»¥ JSON æ ¼å¼è¿”å›ï¼š
{
  "keywords": [...],
  "category": "å‰ç«¯/åç«¯/æ•°æ®åº“/DevOps",
  "confidence": 0.95
}`
  },

  code: {
    system: `ä½ æ˜¯ä»£ç åˆ†æä¸“å®¶ï¼Œèƒ½å¤Ÿä»ä»£ç ç‰‡æ®µä¸­æå–å…³é”®ä¿¡æ¯ã€‚`,
    user: (code, topK) => `ä»ä»¥ä¸‹ä»£ç ä¸­æå– ${topK} ä¸ªå…³é”®è¯ï¼š

å…³æ³¨ç‚¹ï¼š
1. ä¸»è¦åŠŸèƒ½æˆ–ç”¨é€”
2. ä½¿ç”¨çš„æŠ€æœ¯æ ˆ
3. æ ¸å¿ƒå‡½æ•°/ç±»/å˜é‡å
4. è®¾è®¡æ¨¡å¼
5. é‡è¦çš„ç¬¬ä¸‰æ–¹åº“

ä»£ç ï¼š
\`\`\`
${code}
\`\`\`

ä»¥ JSON æ ¼å¼è¿”å›ï¼š
{
  "keywords": [...],
  "language": "ç¼–ç¨‹è¯­è¨€",
  "purpose": "ä»£ç ä¸»è¦ç”¨é€”",
  "confidence": 0.95
}`
  },

  questionnaire: {
    system: `ä½ æ˜¯é—®å·åˆ†æä¸“å®¶ï¼Œæ“…é•¿ä»ç”¨æˆ·åé¦ˆä¸­æå–å…³é”®ä¿¡æ¯å’Œæƒ…æ„Ÿå€¾å‘ã€‚`,
    user: (answer, topK) => `ä»ä»¥ä¸‹é—®å·ç­”æ¡ˆä¸­æå– ${topK} ä¸ªå…³é”®è¯ï¼š

å…³æ³¨ç‚¹ï¼š
1. æƒ…æ„Ÿå€¾å‘è¯ï¼ˆæ»¡æ„ã€ä¸æ»¡ã€æœŸå¾…ç­‰ï¼‰
2. å…·ä½“é—®é¢˜æè¿°
3. åŠŸèƒ½éœ€æ±‚å…³é”®è¯
4. ä½¿ç”¨åœºæ™¯
5. æ”¹è¿›å»ºè®®

ç­”æ¡ˆï¼š
"""
${answer}
"""

ä»¥ JSON æ ¼å¼è¿”å›ï¼š
{
  "keywords": [...],
  "sentiment": "æ­£é¢/è´Ÿé¢/ä¸­æ€§",
  "topic": "ä¸»é¢˜åˆ†ç±»",
  "confidence": 0.95
}`
  }
};
```

### C. æ€§èƒ½ä¼˜åŒ–å»ºè®®

#### 1. æ‰¹é‡å¤„ç†ä¼˜åŒ–

```javascript
// ä½¿ç”¨ Worker Threads å¹¶è¡Œå¤„ç†
import { Worker } from 'worker_threads';

async function parallelExtract(documents, numWorkers = 4) {
  const chunkSize = Math.ceil(documents.length / numWorkers);
  const workers = [];

  for (let i = 0; i < numWorkers; i++) {
    const chunk = documents.slice(i * chunkSize, (i + 1) * chunkSize);
    const worker = new Worker('./keyword-worker.js', {
      workerData: { documents: chunk }
    });
    workers.push(new Promise(resolve => {
      worker.on('message', resolve);
    }));
  }

  const results = await Promise.all(workers);
  return results.flat();
}
```

#### 2. ç¼“å­˜ç­–ç•¥

```javascript
// ä½¿ç”¨ LRU ç¼“å­˜é¿å…é‡å¤è®¡ç®—
import LRU from 'lru-cache';

const keywordCache = new LRU({
  max: 1000,
  ttl: 1000 * 60 * 60  // 1 å°æ—¶
});

function extractWithCache(text, options) {
  const cacheKey = `${text.slice(0, 100)}-${JSON.stringify(options)}`;

  if (keywordCache.has(cacheKey)) {
    return keywordCache.get(cacheKey);
  }

  const keywords = extract(text, options);
  keywordCache.set(cacheKey, keywords);
  return keywords;
}
```

#### 3. æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–

```sql
-- ä¸ºå…³é”®è¯å­—æ®µåˆ›å»º JSON ç´¢å¼•
CREATE INDEX idx_keywords ON knowledge_base(
  (json_extract(keywords, '$'))
);

-- FTS5 ä¼˜åŒ–é…ç½®
CREATE VIRTUAL TABLE knowledge_base_fts USING fts5(
  content,
  keywords,
  content='knowledge_base',
  content_rowid='id',
  tokenize='unicode61 remove_diacritics 2'
);
```

---

## æ€»ç»“

å£®çˆ¸ï¼Œè¿™ä»½è°ƒç ”æŠ¥å‘Šå…¨é¢è¦†ç›–äº†å…³é”®è¯æå–æŠ€æœ¯çš„å„ä¸ªæ–¹é¢ï¼Œé’ˆå¯¹ä½ çš„ RAG ç³»ç»Ÿéœ€æ±‚ï¼Œæˆ‘çš„**æœ€ç»ˆå»ºè®®**æ˜¯ï¼š

### ğŸ¯ æ ¸å¿ƒæ¨è

1. **ä¸»åŠ›æ–¹æ¡ˆ**ï¼š`@node-rs/jieba` + TF-IDF
   - é€Ÿåº¦å¿«ã€æœ¬åœ°åŒ–ã€ä¸­æ–‡ä¼˜åŒ–
   - é€‚åˆ 90% çš„åœºæ™¯

2. **é«˜çº§æ–¹æ¡ˆ**ï¼šOllama + Qwen
   - è´¨é‡é«˜ã€çµæ´»ã€æ·±åº¦ç†è§£
   - ç”¨äºå…³é”®åœºæ™¯

3. **æ··åˆæ£€ç´¢**ï¼šBM25 + å‘é‡ï¼ˆalpha = 0.7ï¼‰
   - å¹³è¡¡ç²¾ç¡®åŒ¹é…å’Œè¯­ä¹‰ç†è§£

### ğŸ“Š å…³é”®å‚æ•°

- **å…³é”®è¯æ•°é‡**ï¼š3-5 ä¸ªï¼ˆæŸ¥è¯¢ï¼‰ã€5-7 ä¸ªï¼ˆæ–‡æ¡£ï¼‰
- **æ··åˆæƒé‡**ï¼š70% å‘é‡ + 30% å…³é”®è¯
- **æœ€å°é•¿åº¦**ï¼š2 å­—ï¼ˆä¸­æ–‡ï¼‰

### ğŸš€ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

å»ºè®®å…ˆå®ç° Phase 1 çš„åŸºç¡€åŠŸèƒ½ï¼ŒéªŒè¯æ•ˆæœåå†é€æ­¥ä¼˜åŒ–ã€‚å¦‚æœéœ€è¦å…·ä½“çš„å®ç°å¸®åŠ©ï¼Œæˆ‘éšæ—¶å¯ä»¥ååŠ©ä½ ï¼

æœ‰ä»»ä½•é—®é¢˜è¯·éšæ—¶æé—®ï¼
